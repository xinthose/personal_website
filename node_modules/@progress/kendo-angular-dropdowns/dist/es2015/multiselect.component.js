/* tslint:disable:max-line-length */
import { guid, isDocumentAvailable, isPresent, isArray, isObjectArray, isChanged, resolveAllValues, selectedIndices, getter, isNumber } from './util';
import { SearchBarComponent } from './searchbar.component';
import { ViewChild, Renderer2, ViewContainerRef, Component, HostBinding, Input, Optional, Inject, ElementRef, Output, EventEmitter, isDevMode, forwardRef, ContentChild, ChangeDetectorRef, KeyValueDiffers, NgZone } from '@angular/core';
import { Subscription } from 'rxjs/Subscription';
import { Subject } from 'rxjs/Subject';
import { catchError } from 'rxjs/operators/catchError';
import { filter } from 'rxjs/operators/filter';
import { map } from 'rxjs/operators/map';
import { tap } from 'rxjs/operators/tap';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { SelectionService } from './selection.service';
import { NavigationService } from './navigation.service';
import { NavigationAction } from './navigation-action';
import { Keys } from './common/keys';
import { ItemTemplateDirective } from './templates/item-template.directive';
import { CustomItemTemplateDirective } from './templates/custom-item-template.directive';
import { HeaderTemplateDirective } from './templates/header-template.directive';
import { FooterTemplateDirective } from './templates/footer-template.directive';
import { TagTemplateDirective } from './templates/tag-template.directive';
import { GroupTagTemplateDirective } from './templates/group-tag-template.directive';
import { NoDataTemplateDirective } from './templates/no-data-template.directive';
import { MultiselectMessages } from './error-messages';
import { PreventableEvent } from './common/preventable-event';
import { RemoveTagEvent } from './common/remove-tag-event';
import { RTL } from '@progress/kendo-angular-l10n';
import { PopupService } from '@progress/kendo-angular-popup';
const MULTISELECT_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    // tslint:disable-next-line:no-use-before-declare
    useExisting: forwardRef(() => MultiSelectComponent)
};
/**
 * Represents the Kendo UI MultiSelect component for Angular.
 *
 * @example
 * ```ts
 * _@Component({
 * selector: 'my-app',
 * template: `
 *  <kendo-multiselect [data]="listItems">
 *  </kendo-multiselect>
 * `
 * })
 * class AppComponent {
 *   public listItems: Array<string> = ["Item 1", "Item 2", "Item 3", "Item 4"];
 * }
 * ```
 */
export class MultiSelectComponent {
    constructor(rtl, popupService, selectionService, navigationService, cdr, differs, renderer, hostElement, _zone) {
        this.popupService = popupService;
        this.selectionService = selectionService;
        this.navigationService = navigationService;
        this.cdr = cdr;
        this.differs = differs;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this._zone = _zone;
        this.activeId = guid();
        this.listBoxId = guid();
        this.focusedTagIndex = undefined;
        /**
         * @hidden
         */
        this.id = guid();
        /**
         * Controls whether to close the suggestion list of the MultiSelect after the selection of an item.
         * @default true
         */
        this.autoClose = true;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Sets the disabled state of the component.
         */
        this.disabled = false;
        /**
         * Sets the readonly state of the component.
         */
        this.readonly = false;
        /**
         * Enables the [filtering]({% slug filtering_multiselect %}) functionality of the MultiSelect.
         */
        this.filterable = false;
        /**
         * If set to `true`, renders a button on hovering over the component.
         * Clicking this button resets the value of the component to an empty array and triggers the `change` event.
         */
        this.clearButton = true;
        /**
         * A user-defined callback function which receives an array of selected data items and maps them to an array of tags.
         *
         * @param { Any[] } dataItems - The selected data items from the list.
         * @returns { Any[] } - The tags that will be rendered by the component.
         */
        this.tagMapper = (tags) => tags || [];
        /**
         * Specifies whether the MultiSelect allows user-defined values that are not present in the dataset.
         * The default value is `false`.
         *
         * For more information, refer to the article on [custom values]({% slug custom_values_multiselect %}).
         */
        this.allowCustom = false;
        /**
         * A user-defined callback function which returns normalized custom values.
         * Typically used when the data items are different from type `string`.
         *
         * @param { Any } value - The custom value that is defined by the user.
         * @returns { Any }
         *
         * @example
         * ```ts
         * import { map } from 'rxjs/operators/map';
         *
         * _@Component({
         * selector: 'my-app',
         * template: `
         *   <kendo-multiselect
         *       [allowCustom]="true"
         *       [data]="listItems"
         *       [textField]="'text'"
         *       [valueField]="'value'"
         *       [valueNormalizer]="valueNormalizer"
         *       (valueChange)="onValueChange($event)"
         *   >
         *   </kendo-multiselect>
         * `
         * })
         *
         * class AppComponent {
         *   public listItems: Array<{ text: string, value: number }> = [
         *       { text: "Small", value: 1 },
         *       { text: "Medium", value: 2 },
         *       { text: "Large", value: 3 }
         *   ];
         *
         *   public onValueChange(value) {
         *       console.log("valueChange : ", value);
         *   }
         *
         *   public valueNormalizer = (text$: Observable<string>) => text$.pipe(map((text: string) => {
         *      return {
         *         ProductID: Math.floor(Math.random() * (1000 - 100) + 1000), //generate unique valueField
         *         ProductName: text };
         *   }));
         *
         * }
         * ```
         */
        this.valueNormalizer = (text) => text.pipe(map((userInput) => {
            const comparer = (item) => userInput.toLowerCase() === item.toLowerCase();
            const matchingValue = this.value.find(comparer);
            if (matchingValue) {
                return matchingValue;
            }
            const matchingItem = this.data.find(comparer);
            return matchingItem ? matchingItem : userInput;
        }));
        /**
         * Fires each time the user types in the input field.
         * You can filter the source based on the passed filtration value.
         */
        this.filterChange = new EventEmitter();
        /**
         * Fires each time the value is changed&mdash;
         * when the component is blurred or the value is cleared through the **Clear** button.
         * For more details, refer to the example on [events]({% slug overview_multiselect %}#toc-events).
         *
         * When the value of the component is changed programmatically through its API or form binding
         * (either to `ngModel` or `formControl`), the `valueChange` event is not triggered because of
         * potentially causing a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel it, the popup will remain closed.
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel it, the popup will remain open.
         */
        this.close = new EventEmitter();
        /**
         * Fires each time the user focuses the MultiSelect.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the MultiSelect gets blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time a tag is about to be removed.
         * This event is preventable. If you cancel it, the tag will not be removed.
         */
        this.removeTag = new EventEmitter();
        this.onChangeCallback = (_) => { };
        this.onTouchedCallback = (_) => { };
        this._data = [];
        this._placeholder = '';
        this._open = false;
        this._value = [];
        this.selectedDataItems = [];
        this._popupSettings = { height: 200, animate: true };
        this.observableSubscriptions = new Subscription();
        this.changeSubscription = new Subscription();
        this.isFocused = false;
        this.wrapperBlurred = new EventEmitter();
        this.customValueSubject = new Subject();
        this.hostElement = hostElement.nativeElement;
        this.popupMouseDownHandler = this.onMouseDown.bind(this);
        this.direction = rtl ? 'rtl' : 'ltr';
        this.subscribeEvents();
    }
    set popupOpen(open) {
        if (this.disabled || this.readonly || this.popupOpen === open) {
            return;
        }
        const eventArgs = new PreventableEvent();
        if (open) {
            this.open.emit(eventArgs);
        }
        else {
            this.close.emit(eventArgs);
        }
        if (eventArgs.isDefaultPrevented()) {
            return;
        }
        this._toggle(open);
    }
    get popupOpen() {
        return this._open;
    }
    /**
     * @hidden
     */
    focusComponent() {
        if (!this.isFocused) {
            this.isFocused = true;
            this.onFocus.emit();
        }
    }
    /**
     * @hidden
     */
    blurComponent() {
        if (this.isFocused) {
            this.closePopup();
            this.isFocused = false;
            if (!this.allowCustom) {
                this.text = "";
            }
            this.onBlur.emit();
            this.onTouchedCallback();
        }
    }
    /**
     * @hidden
     */
    wrapperMousedown(event) {
        if (this.isFocused && event.target === this.searchbar.input.nativeElement) {
            return;
        }
        this.searchbar.focus();
        this.popupOpen = !this.popupOpen;
        event.preventDefault();
    }
    /**
     * @hidden
     */
    onResize() {
        if (this._open) {
            const popupWrapper = this.popupRef.popupElement;
            const { min, max } = this.width;
            popupWrapper.style.minWidth = min;
            popupWrapper.style.width = max;
        }
    }
    get appendTo() {
        const { appendTo } = this.popupSettings;
        if (!appendTo || appendTo === 'root') {
            return undefined;
        }
        return appendTo === 'component' ? this.container : appendTo;
    }
    /**
     * Sets the data of the MultiSelect.
     *
     * > The data has to be provided in an array-like list of items.
     */
    set data(data) {
        this._data = data || [];
    }
    get data() {
        return this._data;
    }
    /**
     * Sets the value of the MultiSelect. It can be either of the primitive (string, numbers) or of the complex (objects) type.
     * To define the type, use the `valuePrimitive` option.
     *
     * > All selected values which are not present in the source are ignored.
     */
    set value(values) {
        this._value = values ? values : [];
        if (!this.differ && this.value) {
            this.differ = this.differs.find(this.value).create();
        }
    }
    get value() {
        return this._value;
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * The hint which is displayed when the component is empty.
     * When the values are selected, it disappears.
     */
    set placeholder(text) {
        this._placeholder = text || '';
    }
    get placeholder() {
        return this.selectedDataItems.length ? '' : this._placeholder;
    }
    /**
     * Configures the popup of the MultiSelect.
     *
     * The available options are:
     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
     * - `width: Number`&mdash;Sets the width of the popup container. By default, the width of the host element is used.
     * - `height: Number`&mdash;Sets the height of the popup container. By default, the height is 200px.
     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
     */
    set popupSettings(settings) {
        this._popupSettings = Object.assign({ height: 200, animate: true }, settings);
    }
    get popupSettings() {
        return this._popupSettings;
    }
    get widgetClasses() {
        return true;
    }
    get dir() {
        return this.direction;
    }
    get focusedClass() {
        return this.isFocused;
    }
    get disabledClass() {
        return this.disabled;
    }
    get listContainerClasses() {
        const containerClasses = ['k-list-container', 'k-reset'];
        if (this.popupSettings.popupClass) {
            containerClasses.push(this.popupSettings.popupClass);
        }
        return containerClasses;
    }
    get width() {
        let wrapperOffsetWidth = 0;
        if (isDocumentAvailable()) {
            wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;
        }
        const width = this.popupSettings.width || wrapperOffsetWidth;
        const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;
        const maxWidth = isNaN(width) ? width : `${width}px`;
        return { min: minWidth, max: maxWidth };
    }
    /**
     * @hidden
     */
    popupOpened() {
        this.popupWidth = this.width.max;
        this.popupMinWidth = this.width.min;
    }
    /**
     * @hidden
     */
    onMouseDown(event) {
        const tagName = event.target.tagName.toLowerCase();
        if (tagName !== "input") {
            event.preventDefault();
        }
    }
    /**
     * @hidden
     */
    verifySettings() {
        const valueOrText = !isPresent(this.valueField) !== !isPresent(this.textField);
        if (!isDevMode() || this.value.length === 0) {
            return;
        }
        if (!isArray(this.value)) {
            throw new Error(MultiselectMessages.array);
        }
        if (this.valuePrimitive === true && isObjectArray(this.value)) {
            throw new Error(MultiselectMessages.primitive);
        }
        if (this.valuePrimitive === false && !isObjectArray(this.value)) {
            throw new Error(MultiselectMessages.object);
        }
        if (valueOrText) {
            throw new Error("Expected textField and valueField options to be set. See http://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/#toc-bind-to-arrays-of-complex-data");
        }
    }
    /**
     * @hidden
     */
    change(event) {
        const isCustomItem = (isPresent(event.added) || isPresent(event.removed)) && (event.added === -1 || event.removed === -1);
        if (isCustomItem) {
            this.addCustomValue(this.text);
            return; //change is emited asynchronosly
        }
        //existing items
        if (isPresent(event.added)) {
            const dataItem = this.data[event.added];
            const newItem = (this.valuePrimitive && isPresent(dataItem[this.valueField])) ? dataItem[this.valueField] :
                dataItem;
            this.value = [...this.value, newItem];
            this.cdr.markForCheck();
        }
        if (isPresent(event.removed)) {
            const dataItem = this.data[event.removed];
            if (this.valuePrimitive) {
                const index = this.value.indexOf(isPresent(dataItem[this.valueField]) ? dataItem[this.valueField] : dataItem);
                this.value.splice(index, 1);
            }
            else {
                this.value = this.value.filter(item => item[this.valueField] !== dataItem[this.valueField]);
            }
            this.cdr.markForCheck();
        }
        this.emitValueChange();
    }
    /**
     * @hidden
     */
    setState(value) {
        const objectArray = isObjectArray(value);
        const selection = selectedIndices(this.value, this.data, this.valueField);
        this.selectionService.resetSelection(selection);
        if (this.popupOpen && this.selectionService.focused === undefined && this.data.length) {
            this.selectionService.focused = 0;
        }
        if (this.selectedDataItems.length <= 0) {
            if (this.valuePrimitive && !this.valueField) {
                this.selectedDataItems = value.slice();
            }
            if (objectArray || this.valuePrimitive && this.valueField) {
                this.selectedDataItems = resolveAllValues(value, this.data, this.valueField);
            }
        }
        this.tags = this.tagMapper(this.selectedDataItems.slice(0));
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    handleBlur() {
        this.wrapperBlurred.emit();
        // this.closePopup();
    }
    /**
     * @hidden
     */
    handleFilter(text) {
        if (this.filterable) {
            this.filterChange.emit(text);
        }
        else {
            this.searchTextAndFocus(text);
        }
        this.text = text;
        this.searchbar.setInputSize();
        if (text && !this.popupOpen) {
            this.openPopup();
        }
    }
    /**
     * @hidden
     */
    clearFilter() {
        if (this.filterable && this.text) {
            this.filterChange.emit("");
        }
        this.text = "";
        this.searchbar.setInputSize();
    }
    /**
     * @hidden
     */
    handleNavigate(event) {
        const navigateInput = this.text && event.keyCode !== Keys.down && event.keyCode !== Keys.up;
        const selectValue = this.text && event.keyCode === Keys.enter || event.keyCode === Keys.esc;
        const deleteTag = !this.text && event.keyCode === Keys.backspace && this.tags.length > 0;
        if (deleteTag) {
            this.handleBackspace();
            return;
        }
        if (this.disabled || navigateInput && !selectValue) {
            return;
        }
        const eventData = event;
        const focused = isNaN(this.selectionService.focused) ? -1 : this.selectionService.focused;
        const action = this.navigationService.process({
            current: focused,
            max: this.data.length - 1,
            min: this.allowCustom && this.text ? -1 : 0,
            open: this.popupOpen,
            originalEvent: eventData
        });
        if (action !== NavigationAction.Undefined &&
            ((action === NavigationAction.Enter && this.popupOpen) || action !== NavigationAction.Enter)) {
            event.preventDefault();
        }
    }
    /**
     * @hidden
     */
    handleRemoveTag(tagData) {
        const eventArgs = new RemoveTagEvent(tagData);
        if (this.disabled || this.readonly) {
            return;
        }
        this.focus();
        this.removeTag.emit(eventArgs);
        if (eventArgs.isDefaultPrevented()) {
            return;
        }
        if (tagData instanceof Array) {
            this.removeGroupTag(tagData);
        }
        else {
            this.removeSingleTag(tagData);
        }
    }
    /**
     * @hidden
     */
    clearAll(event) {
        event.stopImmediatePropagation();
        if (this.filterable && this.text) {
            this.text = "";
            this.filterChange.emit("");
        }
        this.value = [];
        this.selectedDataItems = [];
        this.cdr.markForCheck();
        this.emitValueChange();
        this.setState([]);
    }
    /**
     * @hidden
     */
    addCustomValue(text) {
        this.customValueSubject.next(text);
    }
    ngAfterContentChecked() {
        this.verifySettings();
    }
    ngDoCheck() {
        if (this.differ) {
            const valueChanges = this.differ.diff(this.value);
            if (valueChanges) {
                this.selectedDataItems = this.getSelectedDataItems(valueChanges);
                this.tags = this.tagMapper(this.selectedDataItems.slice(0));
            }
        }
    }
    ngOnInit() {
        this.renderer.removeAttribute(this.hostElement, "tabindex");
        this.createCustomValueStream();
    }
    ngOnChanges(changes) {
        if (this.valuePrimitive === undefined) {
            this.valuePrimitive = !this.valueField;
        }
        if (isChanged("valueNormalizer", changes)) {
            this.createCustomValueStream();
        }
        if (changes.value && this.selectedDataItems.length > 0) {
            //peristed selected data items when list is filtered
            this.selectedDataItems = this.selectedDataItems.concat(this.data).filter(curr => changes.value.currentValue.find(item => item[this.valueField] === curr)).filter(dataItem => !!dataItem); //filter undefined values
        }
        const STATE_PROPS = /(data|textField|valueField|valuePrimitive)/g;
        if (STATE_PROPS.test(Object.keys(changes).join())) {
            this.setState(this.value);
        }
    }
    ngAfterViewInit() {
        this.searchbar.setInputSize();
        this.observableSubscriptions.add(this.searchbar.onFocus.subscribe((event) => {
            if (!this.isFocused) {
                this.isFocused = true;
                this.onFocus.emit(event);
            }
        }));
        this.observableSubscriptions.add(this.searchbar.onBlur.subscribe((event) => {
            if (this.isFocused) {
                this.isFocused = false;
                this.onBlur.emit(event);
                this.onTouchedCallback();
            }
        }));
    }
    ngOnDestroy() {
        this._toggle(false);
        this.unsubscribeEvents();
    }
    /**
     * Focuses the MultiSelect.
     */
    focus() {
        if (!this.disabled) {
            this.searchbar.focus();
        }
    }
    /**
     * Blurs the MultiSelect.
     */
    blur() {
        if (!this.disabled) {
            this.searchbar.blur();
        }
    }
    /**
     * Toggles the visibility of the popup.
     * If you use the `toggle` method to open or close the popup, the respective `open` and `close` events will not be fired.
     *
     * @param open - The state of the popup.
     */
    toggle(open) {
        Promise.resolve(null).then(() => {
            this._toggle((open === undefined) ? !this._open : open);
            this.cdr.markForCheck();
        });
    }
    /**
     * Returns the current open state of the popup.
     */
    get isOpen() {
        return this.popupOpen;
    }
    /**
     * Resets the value of the MultiSelect.
     * If you use the `reset` method to clear the value of the component,
     * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.
     */
    reset() {
        this.text = "";
        this.value = [];
        this.selectedDataItems = [];
        this.setState([]);
        this.cdr.markForCheck();
    }
    // NG MODEL BINDINGS
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value || [];
        this.selectedDataItems = [];
        this.setState(this.value);
        this.verifySettings();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    onTagMapperChange() {
        this.tags = this.tagMapper(this.selectedDataItems.slice(0));
        this.cdr.markForCheck();
    }
    subscribeEvents() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.observableSubscriptions = this.changeSubscription = this.selectionService.onChange.subscribe(this.handleItemChange.bind(this));
        const isOpen = () => this.popupOpen;
        const isClosed = () => !this.popupOpen;
        const isTagFocused = () => !this.popupOpen && this.focusedTagIndex !== undefined;
        [
            this.navigationService.esc.subscribe(this.closePopup.bind(this)),
            this.navigationService.enter.pipe(filter(isOpen)).subscribe(this.handleEnter.bind(this)),
            this.navigationService.open.subscribe(this.openPopup.bind(this)),
            this.navigationService.close.subscribe(this.handleClose.bind(this)),
            this.navigationService.up.pipe(filter(isOpen)).subscribe((event) => this.handleUp(event.index)),
            this.navigationService.home.pipe(filter(() => isClosed)).subscribe(this.handleHome.bind(this)),
            this.navigationService.end.pipe(filter(() => isClosed)).subscribe(this.handleEnd.bind(this)),
            this.navigationService.backspace.pipe(filter(isTagFocused)).subscribe(this.handleBackspace.bind(this)),
            this.navigationService.delete.pipe(filter(isTagFocused)).subscribe(this.handleDelete.bind(this)),
            this.navigationService.left.subscribe(this.handleLeftKey.bind(this)),
            this.navigationService.right.subscribe(this.handleRightKey.bind(this)),
            this.navigationService.down.subscribe((event) => this.handleDownKey(event.index))
        ].forEach(s => this.observableSubscriptions.add(s));
    }
    unsubscribeEvents() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.observableSubscriptions.unsubscribe();
        if (this.customValueSubscription) {
            this.customValueSubscription.unsubscribe();
        }
    }
    removeGroupTag(dataItems) {
        const indices = dataItems.map((dataItem) => selectedIndices([dataItem], this.data, this.valueField)[0]);
        let valuesToRemove = [];
        indices.forEach((currentValue, index) => {
            if (isNumber(currentValue)) {
                this.selectionService.unselect(currentValue);
            }
            else {
                const filter = item => getter(item, this.valueField) !== getter(dataItems[index], this.valueField);
                valuesToRemove.push(this.value.find(filter));
            }
        });
        if (valuesToRemove.length) {
            let newValue = this.value.slice();
            let newSelectedDataItems = this.selectedDataItems.slice();
            valuesToRemove.forEach((value) => {
                const filter = item => getter(item, this.valueField) !== value;
                newValue = newValue.filter(filter);
                newSelectedDataItems = newSelectedDataItems.filter(filter);
            });
            this.value = newValue;
            this.selectedDataItems = newSelectedDataItems;
        }
        this.tags = this.tagMapper(this.selectedDataItems.slice(0));
        this.cdr.markForCheck();
        this.emitValueChange();
    }
    removeSingleTag(dataItem) {
        const index = selectedIndices([dataItem], this.data, this.valueField)[0];
        if (isNumber(index)) {
            this.selectionService.unselect(index);
            this.popupOpen = false;
        }
        else {
            const filter = item => getter(item, this.valueField) !== getter(dataItem, this.valueField);
            this.value = this.value.filter(filter);
            this.selectedDataItems = this.selectedDataItems.filter(filter);
            this.tags = this.tagMapper(this.selectedDataItems.slice(0));
            this.cdr.markForCheck();
            this.emitValueChange();
        }
    }
    createCustomValueStream() {
        if (this.customValueSubscription) {
            this.customValueSubscription.unsubscribe();
        }
        this.customValueSubscription = this.customValueSubject.pipe(tap(() => {
            this.loading = true;
            this.disabled = true;
        }), this.valueNormalizer, catchError(() => {
            this.loading = false;
            this.disabled = false;
            this.text = "";
            this.filterChange.emit("");
            if (this.autoClose) {
                this.popupOpen = false;
                this.nextTick(() => {
                    this.searchbar.focus();
                });
            }
            return this.customValueSubject;
        }))
            .subscribe((normalizedValue) => {
            this.loading = false;
            this.disabled = false;
            this.text = "";
            this.filterChange.emit("");
            if (isPresent(normalizedValue)) {
                const newValue = this.valuePrimitive ? getter(normalizedValue, this.valueField) : normalizedValue;
                if (this.value.indexOf(newValue) === -1) {
                    this.value = [...this.value, newValue];
                    this.selectedDataItems = [...this.selectedDataItems, normalizedValue];
                }
                else {
                    this.value.splice(this.value.indexOf(newValue), 1);
                    this.selectedDataItems = this.selectedDataItems.filter(item => getter(item, this.valueField) !== newValue);
                }
                this.tags = this.tagMapper(this.selectedDataItems.slice(0));
                this.emitValueChange();
            }
            if (this.autoClose) {
                this.popupOpen = false;
                this.nextTick(() => {
                    this.searchbar.focus();
                });
            }
        });
    }
    handleItemChange(event) {
        if (isPresent(event.added) && event.added !== -1) {
            this.clearFilter();
        }
        this.change(event);
        if (this.autoClose) {
            this.popupOpen = false;
        }
    }
    handleEnter(event) {
        const focusedIndex = this.selectionService.focused;
        if (this.popupOpen) {
            event.originalEvent.preventDefault();
        }
        if (focusedIndex === -1 && !this.allowCustom) {
            return;
        }
        if (focusedIndex === -1 && this.text) {
            this.addCustomValue(this.text);
            return; //clear filter & close popup at customValueSubscription due to race conditions
        }
        if (this.selectionService.isSelected(focusedIndex)) {
            this.selectionService.unselect(focusedIndex);
        }
        else {
            this.selectionService.add(focusedIndex);
        }
        this.clearFilter();
        if (this.autoClose) {
            this.popupOpen = false;
        }
    }
    handleClose() {
        this.closePopup();
        this.searchbar.focus();
    }
    handleEnd() {
        this.focusedTagIndex = this.tags.length - 1;
    }
    handleHome() {
        this.focusedTagIndex = 0;
    }
    handleUp(index) {
        this.selectionService.focused = index;
    }
    handleBackspace() {
        if (this.focusedTagIndex !== undefined) {
            this.handleDelete();
            return;
        }
        this.handleRemoveTag(this.tags[this.tags.length - 1]);
        this.searchbar.focus();
    }
    handleDelete() {
        this.handleRemoveTag(this.tags[this.focusedTagIndex]);
        if (this.focusedTagIndex === this.tags.length) {
            this.focusedTagIndex = undefined;
        }
    }
    handleLeftKey() {
        if (this.direction === 'rtl' && this.focusedTagIndex === 0) {
            this.focusedTagIndex = undefined;
            return;
        }
        if (this.direction === 'rtl' && this.focusedTagIndex === undefined) {
            return;
        }
        if (this.focusedTagIndex === undefined || this.focusedTagIndex < 0) {
            this.focusedTagIndex = this.tags.length - 1;
        }
        else if (this.focusedTagIndex !== 0) {
            this.focusedTagIndex--;
        }
    }
    handleDownKey(index) {
        if (this.popupOpen) {
            this.selectionService.focused = index || 0;
        }
        else {
            this.openPopup();
        }
    }
    handleRightKey() {
        const last = this.tags.length - 1;
        if (this.direction === 'rtl' && this.focusedTagIndex === undefined) {
            this.focusedTagIndex = 0;
            return;
        }
        if (this.direction === 'rtl' && this.focusedTagIndex === last) {
            return;
        }
        if (this.focusedTagIndex === last) {
            this.focusedTagIndex = undefined;
        }
        else if (this.focusedTagIndex < last) {
            this.focusedTagIndex++;
        }
    }
    findIndex(text) {
        return this.data.findIndex(item => {
            let itemText = getter(item, this.textField);
            itemText = itemText === undefined ? "" : itemText.toString().toLowerCase();
            return itemText.startsWith(text.toLowerCase());
        });
    }
    searchTextAndFocus(text) {
        const index = this.allowCustom && text ? -1 : this.findIndex(text);
        this.selectionService.focused = index;
    }
    closePopup() {
        this.popupOpen = false;
        this.focusedTagIndex = undefined;
    }
    openPopup() {
        this.popupOpen = true;
        this.focusedTagIndex = undefined;
    }
    emitValueChange() {
        this.onChangeCallback(this.value);
        this.valueChange.emit(this.value);
    }
    _toggle(open) {
        this._open = open;
        if (this.popupRef) {
            this.popupRef.popupElement
                .removeEventListener('mousedown', this.popupMouseDownHandler);
            this.popupRef.close();
            this.popupRef = null;
        }
        if (this._open) {
            this.popupRef = this.popupService.open({
                anchor: this.wrapper,
                animate: this.popupSettings.animate,
                appendTo: this.appendTo,
                content: this.popupTemplate,
                popupClass: this.listContainerClasses,
                positionMode: 'absolute'
            });
            const popupWrapper = this.popupRef.popupElement;
            const { min, max } = this.width;
            popupWrapper.addEventListener('mousedown', this.popupMouseDownHandler);
            popupWrapper.style.minWidth = min;
            popupWrapper.style.width = max;
            popupWrapper.setAttribute("dir", this.direction);
            this.popupRef.popupOpen.subscribe(this.popupOpened.bind(this));
            this.popupRef.popupAnchorViewportLeave.subscribe(() => this.popupOpen = false);
        }
    }
    getSelectedDataItems(valueChanges) {
        if (!this.data.length && this.valuePrimitive && this.valueField) {
            return [];
        }
        let selectedDataItems = [];
        valueChanges.forEachItem((value) => {
            const currentValue = value.currentValue;
            const isBoundToComplexData = isObjectArray(this.data);
            const index = this.data.findIndex((item) => {
                const value = this.valuePrimitive ? currentValue : getter(currentValue, this.valueField);
                return getter(item, this.valueField) === value;
            });
            if (index !== -1) {
                this.selectionService.select(index);
                selectedDataItems.push(this.data[index]);
            }
            else if (isPresent(value) && !(isBoundToComplexData && this.valuePrimitive)) {
                selectedDataItems.push(currentValue);
            }
        });
        return selectedDataItems;
    }
    nextTick(f) {
        this._zone.runOutsideAngular(() => {
            // Use `setTimeout` instead of a resolved promise
            // because the latter does not wait long enough.
            setTimeout(() => this._zone.run(f));
        });
    }
}
MultiSelectComponent.decorators = [
    { type: Component, args: [{
                exportAs: 'kendoMultiSelect',
                providers: [MULTISELECT_VALUE_ACCESSOR, SelectionService, NavigationService],
                selector: 'kendo-multiselect',
                template: `
        <div class="k-multiselect-wrap k-floatwrap"
            #wrapper
            (mousedown)="wrapperMousedown($event)"
        >
            <kendo-taglist
                [tags]="tags"
                [textField]="textField"
                [focused]="focusedTagIndex"
                [disabled]="disabled"
                [template]="tagTemplate"
                [groupTemplate]="groupTagTemplate"
                [activeId]="activeId"
                (removeTag)="handleRemoveTag($event)"
            >
            </kendo-taglist>
            <kendo-searchbar
                #searchbar
                [id]="id"
                [role]="'listbox'"
                [listId]="listBoxId"
                [activeDescendant]="activeId"
                [userInput]="text"
                [disabled]="disabled"
                [readonly]="readonly"
                [tabIndex]="tabIndex"
                [popupOpen]="popupOpen"
                [placeholder]="placeholder"
                (onNavigate)="handleNavigate($event)"
                (valueChange)="handleFilter($event)"
                (onBlur)="blurComponent()"
                (onFocus)="focusComponent()"
            >
            </kendo-searchbar>
            <span *ngIf="!loading && !readonly && clearButton && (tags?.length || text?.length)" class="k-icon k-clear-value k-i-close" title="clear" role="button" tabindex="-1" (mousedown)="clearAll($event)"></span>
            <span *ngIf="loading" class="k-icon k-i-loading"></span>
        </div>
        <ng-template #popupTemplate>
            <!--header template-->
            <ng-template *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate.templateRef
                }">
            </ng-template>
            <!--custom item template-->
            <div class="k-list k-multiselect-custom-item" *ngIf="allowCustom && text">
                <div class="k-item" kendoDropDownsSelectable [multipleSelection]="true" [index]="-1">
                    <ng-template *ngIf="customItemTemplate;else default_custom_item_template"
                        [templateContext]="{
                            templateRef: customItemTemplate.templateRef,
                            $implicit: text
                        }">
                    </ng-template>
                    <ng-template #default_custom_item_template>{{ text }}</ng-template>
                    <span class="k-icon k-i-plus" style="float: right"></span>
                </div>
            </div>
            <!--list-->
            <kendo-list
                [id]="listBoxId"
                [data]="data"
                [textField]="textField"
                [valueField]="valueField"
                [height]="popupSettings?.height"
                [template]="template"
                [show]="popupOpen"
                [multipleSelection]="true"
                >
            </kendo-list>
            <!--no data template-->
            <div class="k-nodata" *ngIf="data.length === 0">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>NO DATA FOUND.</div>
                </ng-template>
            </div>
            <!--footer template-->
            <ng-template *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate.templateRef
                }">
            </ng-template>
        </ng-template>
        <ng-template [ngIf]="popupOpen">
            <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>
        </ng-template>
        <ng-container #container></ng-container>
  `
            },] },
];
/** @nocollapse */
MultiSelectComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] },] },
    { type: PopupService, },
    { type: SelectionService, },
    { type: NavigationService, },
    { type: ChangeDetectorRef, },
    { type: KeyValueDiffers, },
    { type: Renderer2, },
    { type: ElementRef, },
    { type: NgZone, },
];
MultiSelectComponent.propDecorators = {
    'id': [{ type: Input },],
    'autoClose': [{ type: Input },],
    'loading': [{ type: Input },],
    'data': [{ type: Input },],
    'value': [{ type: Input },],
    'valueField': [{ type: Input },],
    'textField': [{ type: Input },],
    'tabindex': [{ type: Input },],
    'tabIndex': [{ type: Input, args: ["tabIndex",] },],
    'placeholder': [{ type: Input },],
    'disabled': [{ type: Input },],
    'readonly': [{ type: Input },],
    'filterable': [{ type: Input },],
    'popupSettings': [{ type: Input },],
    'valuePrimitive': [{ type: Input },],
    'clearButton': [{ type: Input },],
    'tagMapper': [{ type: Input },],
    'allowCustom': [{ type: Input },],
    'valueNormalizer': [{ type: Input },],
    'filterChange': [{ type: Output },],
    'valueChange': [{ type: Output },],
    'open': [{ type: Output },],
    'close': [{ type: Output },],
    'onFocus': [{ type: Output, args: ['focus',] },],
    'onBlur': [{ type: Output, args: ['blur',] },],
    'removeTag': [{ type: Output },],
    'container': [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] },],
    'searchbar': [{ type: ViewChild, args: [SearchBarComponent,] },],
    'popupTemplate': [{ type: ViewChild, args: ['popupTemplate',] },],
    'wrapper': [{ type: ViewChild, args: ['wrapper',] },],
    'template': [{ type: ContentChild, args: [ItemTemplateDirective,] },],
    'customItemTemplate': [{ type: ContentChild, args: [CustomItemTemplateDirective,] },],
    'headerTemplate': [{ type: ContentChild, args: [HeaderTemplateDirective,] },],
    'footerTemplate': [{ type: ContentChild, args: [FooterTemplateDirective,] },],
    'tagTemplate': [{ type: ContentChild, args: [TagTemplateDirective,] },],
    'groupTagTemplate': [{ type: ContentChild, args: [GroupTagTemplateDirective,] },],
    'noDataTemplate': [{ type: ContentChild, args: [NoDataTemplateDirective,] },],
    'widgetClasses': [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-multiselect',] }, { type: HostBinding, args: ['class.k-header',] },],
    'dir': [{ type: HostBinding, args: ['attr.dir',] },],
    'focusedClass': [{ type: HostBinding, args: ['class.k-state-focused',] },],
    'disabledClass': [{ type: HostBinding, args: ['class.k-state-disabled',] },],
};
