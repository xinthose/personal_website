import { Injectable, EventEmitter } from '@angular/core';
import { isPresent } from './util';
import { Keys } from './common/keys';
import { NavigationAction } from './navigation-action';
import { DisabledItemsService } from './disabled-items.service';
const MIN_INDEX = 0;
/**
 * @hidden
 */
export class NavigationEvent {
    /**
     * The index of the item to which the user navigated.
     */
    constructor(index, originalEvent) {
        this.index = index;
        this.originalEvent = originalEvent;
    }
}
/**
 * @hidden
 */
export class NavigationService {
    constructor(disabledItemsService) {
        this.disabledItemsService = disabledItemsService;
        this.open = new EventEmitter();
        this.close = new EventEmitter();
        this.enter = new EventEmitter();
        this.tab = new EventEmitter();
        this.esc = new EventEmitter();
        this.up = new EventEmitter();
        this.right = new EventEmitter();
        this.down = new EventEmitter();
        this.left = new EventEmitter();
        this.delete = new EventEmitter();
        this.backspace = new EventEmitter();
        this.home = new EventEmitter();
        this.end = new EventEmitter();
    }
    process(args) {
        const keyCode = args.originalEvent.keyCode;
        const altKey = args.originalEvent.altKey;
        let index;
        let action = NavigationAction.Undefined;
        if (altKey && keyCode === Keys.down) {
            action = NavigationAction.Open;
        }
        else if (altKey && keyCode === Keys.up) {
            action = NavigationAction.Close;
        }
        else if (keyCode === Keys.enter) {
            action = NavigationAction.Enter;
        }
        else if (keyCode === Keys.esc) {
            action = NavigationAction.Esc;
        }
        else if (keyCode === Keys.tab) {
            action = NavigationAction.Tab;
        }
        else if (keyCode === Keys.up) {
            index = this.next({ current: args.current, start: args.max, end: args.min, step: -1 });
            action = NavigationAction.Up;
        }
        else if (keyCode === Keys.left) {
            index = this.next({ current: args.current, start: args.max, end: args.min, step: -1 });
            action = NavigationAction.Left;
        }
        else if (keyCode === Keys.down) {
            index = this.next({ current: args.current, start: args.min, end: args.max, step: 1 });
            action = NavigationAction.Down;
        }
        else if (keyCode === Keys.right) {
            index = this.next({ current: args.current, start: args.min, end: args.max, step: 1 });
            action = NavigationAction.Right;
        }
        else if (keyCode === Keys.home) {
            index = this.isDisabled(MIN_INDEX) ? args.current : MIN_INDEX;
            action = NavigationAction.Home;
        }
        else if (keyCode === Keys.end) {
            index = this.isDisabled(args.max) ? args.current : args.max;
            action = NavigationAction.End;
        }
        else if (keyCode === Keys.delete) {
            action = NavigationAction.Delete;
        }
        else if (keyCode === Keys.backspace) {
            action = NavigationAction.Backspace;
        }
        const eventData = new NavigationEvent(index, args.originalEvent);
        if (action !== NavigationAction.Undefined) {
            this[NavigationAction[action].toLowerCase()].emit(eventData);
        }
        return action;
    }
    next(args) {
        let nextIndex;
        if (!isPresent(args.current)) {
            nextIndex = args.start;
        }
        else {
            nextIndex = args.current !== args.end ? args.current + args.step : args.end;
        }
        if (!this.isDisabled(nextIndex)) {
            return nextIndex;
        }
        else {
            //start and end are changed according to the navigation direction
            const isInBound = (args.start < args.end) ?
                (i) => i >= args.start && i <= args.end : (i) => i >= args.end && i <= args.start;
            while (isInBound(nextIndex)) {
                if (!this.isDisabled(nextIndex)) {
                    return nextIndex;
                }
                nextIndex = nextIndex + args.step;
            }
            return args.current;
        }
    }
    isDisabled(index) {
        if (this.disabledItemsService) {
            return this.disabledItemsService.isIndexDisabled(index);
        }
    }
}
NavigationService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NavigationService.ctorParameters = () => [
    { type: DisabledItemsService, },
];
